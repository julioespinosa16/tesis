\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lscape}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{multirow}
\usepackage[thinlines]{easytable}
\usepackage{array}
\usepackage{adjustbox}
\usepackage{pbox}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\usepackage{pifont}
\usepackage{tablefootnote}
\usepackage{xspace}
\usepackage{subcaption}
\usepackage{scrextend}
\usepackage{url}
\usepackage{amssymb}
\usepackage{multirow}
%\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{dirtytalk}

\usepackage{listings} % Para usar código fuente


\renewcommand{\thefigure}{\arabic{figure}}
\renewcommand{\thesubfigure}{\arabic{subfigure}}
 
 
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}

\mathchardef\period=\mathcode`.
\DeclareMathSymbol{.}{\mathord}{letters}{"3B}

%BibTexChicago
\usepackage[notes,natbib,isbn=false,backend=biber]{biblatex-chicago}
\usepackage[spanish]{babel}
%\usepackage[utf8]{inputenc}
\usepackage{csquotes}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsthm}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage[font=small,labelfont=bf]{caption}


{\doublespacing}

\newtheorem{theorem}{Teorema}
\newtheorem{definition}{Definición}
\newtheorem*{prueba}{Demostración}

\addbibresource{biblio.bib}

\title{Foto-mosaicos y optimización para el arte (Opt-Art)}
\author{  {Julio César Espinosa}
}
\date{Verano 2021}


\begin{document}
\begin{doublespace}

\maketitle

\section{Introducción}\label{section:intro}

Históricamente, la optimización matemática ha sido una disciplina altamente recurrida para la solución de problemas en varias áreas del conocimiento (economía, informática, industria, logística, etc.) y en distintos grados de complejidad. Sin embargo, fuera de la amplia esfera de problemas técnicos o puramente científicos abordables por la optimización hay una serie planteamientos resolvibles que concilian la optimización, particularmente del tipo lineal, con problemas de carácter estético más vinculados con ramas como el arte o la composición fotográfica. La presente tesina abordará el problema de reproducir o replicar con buena similaridad una imagen mediante el empleo, ya sea de trazos continuos a lo largo de un cuadro, o mediante imágenes diversas que, posicionadas estratégicamente, lograrán construir un producto que, a ojo humano, tendrá una forma fácilmente asociable con la imagen objetivo. Siendo ambos problemas de optimización lineal entera: el primero, una aplicación del problema del agente viajero (TSP por sus siglas en inglés); y el segundo, un problema lineal con variables de decisión en tres dimensiones (asociadas a renglón, columna y tipo de imagen). 

\section{TSP: Agente viajero}\label{section:tsp}

%\subsection{Nuevo rival - Cardoso, et. al.}

La teoría de grafos estudia las propiedades y relaciones de un grafo que es un par $(V,E)$ con $V$ un conjunto de vértices y $E$ conjunto de aristas que los une. Siendo la arista modelada, ya sea como un par dirigido, donde el orden de los vértices importa (digrafo), o bien, no dirigido. Existen problemas de optimización planteados sobre esquemas de grafos que pueden ser resueltos por la vía de la programación lineal, siendo el problema del agente viajero (\textit{Traveling Salesman Problem}, TSP) uno de los más interesantes y populares. Este problema se esboza partiendo de un individuo (agente) que desea visitar una cantidad $n_{*}$ de ciudades partiendo de una ciudad origen y finalizando el recorrido en dicha ciudad con el objetivo de minimizar la distancia total recorrida. Existe un único conjunto de parámetros necesario para definir el problema: la distancia que hay entre cada par de ciudades existente; para ello defínase $c_{i, j}$ como el valor cuantitativo de dicha la distancia que hay entre las ciudades (o vértices) $(i, j)$ para cada par $(i, j) \in \{1,\dots ,n_{*}\}^2$.  Explicado este problema, podemos desarrollar una intuitiva formulación matemática mediante la programación lineal entera siguiente.


\begin{subequations}

\begin{equation}\label{uno} 
 \underset{x_{i, j}  }{\text{min}}
 \sum_{i=1}^{n_{*}} \sum_{j=1}^{n_{*}} c_{i, j}x_{i, j} \\
\end{equation}  

\begin{equation}\label{dos} 
 \text{s.a.}
 \sum_{i=1}^{n_{*}} x_{i, j}=1 \hspace{0.5cm}   \forall j \in \{ 1, \dots , n_{*} \} \\
\end{equation}

\begin{equation}\label{tres} 
\;\;\;\;\; \sum_{j=1}^{n_{*}} x_{i, j}=1  \hspace{0.5cm}   \forall i \in \{ 1, \dots , n_{*} \} \\
\end{equation}

\begin{equation}\label{cuatro} 
\;\;\;\;\; \sum_{i \in S}\sum_{j \in S}  x_{i, j} \leq |S|-1 \hspace{0.5cm}   \forall S \subset \{ 1, \dots ,  n_{*} \}
\end{equation}

\end{subequations}


%\begin{equation}\label{tsp} 
%\begin{aligned}
%& \underset{x_{i, j}  }{\text{min}}
%& & \sum_{i=1}^{n_{*}} \sum_{j=1}^{n_{*}} c_{i, j}x_{i, j} \\
%& \text{s.a.}
%& & \sum_{i=1}^{n_{*}} x_{i, j}=1 \hspace{0.5cm}   \forall j \in \{ 1, ..., n_{*} \} \\
%& & & \sum_{j=1}^{n_{*}} x_{i, j}=1  \hspace{0.5cm}   \forall i \in \{ 1, ..., n_{*} \} \\
%& & & \sum_{i \in S}\sum_{j \in S}  x_{i, j} \leq |S|-1 \hspace{0.5cm}   \forall S \subset \{ 1, ..., %n_{*} \}
%\end{aligned}
%&\end{equation}
 
 Donde $S$ es el conjunto potencia generado con $\{ 1, \dots , n_{*} \}$. El problema lineal esbozado arriba se conforma por componentes. Para entenderlo, defínase antes el conjunto de variables de decisión como 
 $\{ x_{i,j} | (i, j) \in \{1, \dots , n_{*} \}^{2} \}$ con dos asignaciones de valor posibles: $0$ y $1$. $1$ representa que el agente realizó un recorrido directo partiendo de la ciudad $i$ hacia la ciudad $j$ con una distancia correspondiente de $c_{i, j}$; $0$, por el contrario, representa el caso opuesto. En términos técnicos, el agente viajero ocupó el dígrafo dirigido $(i, j)$.
 
 Así, la primera expresión ec.  \eqref{uno} es la función objetivo: el recorrido total para arribar a las $n_{*}$ ciudades. \eqref{dos} exige que de cada ciudad se parta hacia una única ciudad; \eqref{tres}, análogo a \eqref{dos}, requiere que a cada ciudad se arribe desde un único punto de partida. La factibilidad del \textit{tour} generado por el agente se termina de construir en el conjunto \eqref{cuatro}, ya que sin éste podrían haber \textit{tours} donde a cada ciudad se llega una única vez y cada ciudad parte hacia un único destino, pero dos o más subconjuntos resultado de la partición de $ \{ 1, \dots , n_{*} \}$ generan cada uno un recorrido o \textit{tour} cerrado. Supongamos que se generó una solución optimal con las restricciones \eqref{dos} y \eqref{tres} cumplidas, pero que constara de tres \textit{subtours}: $T_{1}, T_{2}, T_{3}$ con $T_{1} \cup T_{2}  \cup T_{3} = \{ 1, \dots , n_{*} \}$. Poniéndonos imaginativos, esto querría decir que el agente terminó de recorrer $T_{1}$, al terminar 'se teletransportó' a $T_{2}$ sin recorrer distancia alguna, finalmente siguió haciendo lo propio de $T_{2}$ a $T_{3}$. Claramente esto no tiene sentido en el plano real; además, se viola el supuesto de que el agente parte de un punto y termina en el mismo tras recorrer todas las ciudades. La restricción \eqref{cuatro} elimina la posibilidad de \textit{subtours}. Sin embargo, al tratarse de una restricción que explora a cada uno de los $2^{n_{*}}$ posibles subconjuntos generables con  $\{ 1, \dots , n_{*} \}$, es una restricción con una elevada complejidad computacional asociada que debe simplificarse con adecuadas restricciones alternativas (véanse restricciones de Miller, Tucker  \& Zemlin,  1960). Si a eso le sumamos que el programa lineal tiene como conjunto factible los $n_{*}!$ posibles ordenamientos de $\{ 1, ..., n_{*} \}$, podemos entender que se diga que los programas que lo resuelven trabajan bajo los llamados \say{algoritmos de optimización combinatoria}. 

\subsection{Arte con el agente viajero}\label{ssec:tspDescrip}

En la introducción se hace referencia a dos maneras de replicar imágenes con optimización lineal que se desarrollarán en el presente estudio. La primer versión es vía el TSP: parte del supuesto de que se cuenta con una imagen en blanco y negro con una gama de \textit{greyscales} (o escala de grises\footnotetext{En adelante se emplearan indistintamente '\textit{greyscales}' o 'escala de grises'}). Asociamos una mayor \textit{greyscale} a una mayor luminosidad o blancura. Así pues, procedemos de la siguiente manera

\begin{itemize}
	\item Particionamos la imagen en grupos de pixeles. Cada grupo constará de rectángulos con $k$ pixeles a lo largo por $h$ pixeles a lo ancho. Derivamos de la imagen $m$ submatrices-renglón de grupos o rectángulos y $n$ submatrices-columna de éstos, de tal manera que la matriz grande cuenta con dimensiones $\mu' \times \nu'$ con $\mu'= k\;m$ y $\nu'= h\;n$; asímismo, obtenemos una escala de grises para cada pixel en el rango discreto de $0$ a $255$. 
	\item Obtenemos la \textit{greyscale} promedio de cada rectángulo y fijamos un parámetro que ponderará el nivel de detalle que deseamos para la imagen a reproducir: $\gamma \in [4, 9] \cap \mathbb{N}$. De tal manera, para el rectángulo $(i, j) \in \{1, \dots , m \} \times \{1, \dots , n  \}$ la \textit{greyscale} del pixel promedio será de $\psi_{ij}$, con valores entre $0$ y $255$. De tal forma constrúyase
	
	\begin{equation}\label{oscG} 
	\begin{aligned}
	g_{ij}=  \floor{ \gamma -  \gamma \psi_{ij}/255} \in [0, \gamma]
	\end{aligned}
	\end{equation}
	
	Esta será una escala de oscuridad del rectángulo.
    \item Dividimos la imagen en $m \times n$ rectángulos, en cada uno situamos uniformemente $g_{ij}$ ciudades. El conjunto total de ciudades construidas será de cardinalidad $\tau$, definida como
    
    \begin{equation}\label{totalCiudades} 
	\begin{aligned}
	\tau=\sum_{i=1}^{m } \sum_{j=1}^{n} g_{ij}
	\end{aligned}
	\end{equation}
	
    Computamos las distancias (o \say{costos}) entre las $\tau$ distintas coordenadas en una matriz $C=[c]_{ij}$  de $\tau \times \tau$; resolvemos el TSP sobre estas distancias. Siendo que ahora el planteamiento se esboza sobre $\tau$ ciudades y relacionándolo con la expresión para el agente viajero explicada al inicio de esta sección, podemos entender que ahora $n_{*}=\tau$.
\end{itemize}


\section{Foto mosaicos}

En el área del \textit{marketing} han pululado técnicas de \textit{advertising} que consisten en reproducir con elevada similaridad una imagen de interés conformada por un conjunto de imágenes  o grupos de pixeles. Similar al ejercicio del TSP aplicado al cuadro de la Monalisa podríamos asignar una intensidad lumínica a cada celda del mismo (o cualquier otro) rectángulo, reescalando el parámetro $\psi_{ij}$ al intervalo $[0, 1]$ mediante $\beta_{ij}=\psi_{ij}/255$. Así, de manera similar al punto (1), supóngase que contamos con un conjunto $F=\{ 1, \dots  , cf\}$ de rectángulos (con $cardinalidad(F)=cf$), cada rectángulo representando a, digamos, una fotografía. Cada imagen o figura de tipo $f \in F$ cuenta con una intensidad lumínica con valor $b_{f}$. Además, supóngase que se cuenta con a lo menos un rectángulo con la fotografía $f$ impresa, pero podemos tener más: $u_{f}$ es la cantidad de rectángulos de tipo $f$ disponible para su uso. De tal manera contamos con un total de $\sum u_{f}=U \geq m \; n$ fichas disponibles. La formulación con programación lineal del problema de los fotomosaicos es la siguiente. 


%\begin{equation}\label{fotomosaicos} 
%\begin{aligned}
%& \underset{x_{f i j}  }{\text{min}}
%& &  \sum_{f \in F} \sum_{i=1}^{n} \sum_{j=1}^{n} (b_{f}-\beta_{ij})^2 x_{f i j} \\
%& \text{s.a.}
%& &\sum_{i=1}^{n} \sum_{j=1}^{n} x_{f i j} \leq u_{f} \hspace{0.5cm}   \forall f \in F \\
%& & & \sum_{f \in F} x_{f i j}=1  \hspace{0.5cm}   \forall (i, j) \in \{ 1, ..., m \}  \times  \{ 1, ..., %n  \}  \\
%\end{aligned}
%\end{equation}


\begin{subequations}

\begin{equation}\label{unoM} 
\underset{x_{f i j}  }{\text{min}}
 \sum_{f \in F} \sum_{i=1}^{n} \sum_{j=1}^{n} (b_{f}-\beta_{ij})^2 x_{f i j} \\
\end{equation}  

\begin{equation}\label{dosM} 
\text{s.a.}
\sum_{i=1}^{n} \sum_{j=1}^{n} x_{f i j} \leq u_{f} \hspace{0.5cm}   \forall f \in F \\
\end{equation}


\begin{equation}\label{tresM} 
\sum_{f \in F} x_{f i j}=1  \hspace{0.5cm}   \forall (i, j) \in \{ 1, \dots , m \}  \times  \{ 1, \dots , n  \}  \\
\end{equation}

\end{subequations}


%\eqref{totalCiudades} 

La expresión ec. \eqref{unoM}  minimiza la suma de diferencias cuadráticas entre las luminosidades del área subyacente sobre la cual se coloca la ficha $f$ en la posición $(i, j)$ (Possani). La función de costos $c_{i,j}$ del problema viajero ahora tiene un análogo tridimensional: $c_{fij}=(b_{f}-\beta_{ij})^2$. \eqref{dosM} garantiza que se no se excedan las dotaciones disponibles de cada figura. La restricción \eqref{tresM} se asegura que haya exactamente una foto en la posición $(i, j)$. Cabe destacar que, si bien este problema es de programción lineal entera (los valores factibles son solo $0$ y $1$), el mismo se puede plantear como un problema con variables de decisión continuas, dando lugar a un resultado optimal entero y factible. Esto es una noticia buena en la medida de que añadir la propiedad de \say{entero} o \say{enterez} implica en la solución restricciones asociadas con una complejidad computacional y de planteamiento no siempre tan triviales. En otras palabras, la restricción de enterez dificulta el cálculo de soluciones.  


\section{Implementación}\label{subsection:partic}

\subsection{Partición de la matriz en submatrices}\label{ssec:partic}

Una imagen en escala de grises se entiende como un despliegue visual en el que cada unidad básica mostrada en la pantalla —mejor conocida como pixel— se ve representada por una cifra que cuantifica la cantidad de luz (o información de intensidad lumínica) con que cuenta. Representando la mínima unidad al negro y, la máxima, al blanco. La escala tiende a volverse discreta, ya que contar con un continuo estándar de $0$ a $1$ (o $0\%$ a $100\%$) representaría un reto computacional y de almacenaje considerable. Algunas imágenes en escala de grises tempranas cuantificaban hasta 16 valores, lo cual implicaba un almacenaje de 4 bits por pixel; en la medida de que la rama de la fotografía digital evolucionó, aumentó hasta 256 intensidades, implicando un peso de 8 bits por pixel. Si bien actualmente hay adicionales variaciones con mayor o menor número de valores (también discretos), los cuales se eligen en función de la aplicación de la imagen, un estándar recurrentemente usado es el de 256 escalas. Por eso, y en aras de seguir convenciones, se usará esta escala discreta, o bien, la escala continua de $0$ a $1$. Para pasar de la escala $[0,1]$ a la escala $\{0, \dots , 255\}$ hacemos $e_{255}=round(255 e_{1})$; para pasar en sentido inverso se usará $e_{1}=\frac{1}{255}e_{255}$.

En este apartado se describirá cómo se procede para formular y computar los dos enfoques para reproducir imágenes: el de TSP y el de los fotomosaicos, explicados brevemente en la sección  \ref{section:tsp} \footnotetext{mostrar número de sección}
. Para iniciar los ejercicios decidí usar una imagen de la red social Twitter, la cual se anexa a continuación. La librería de R encargada de procesar y graficar las imágenes de tipo png tiene como nombre \say{png}. La función $readPNG( \period )$ se encarga de leer el archivo-imagen objetivo y sintetizarlo en un objeto numérico estructurado en un arreglo 3-dimensional con dimensiones para sus pixeles de renglón ($\mu$) $\times$ columna ($\nu$) $\times 3$. De los elementos extrapolados del primer componente de la dimensión tres, $readPNG( \period )[,,1]$, se extrae una matriz $\mu \times \nu$, la cual consta de valores constituyendo la escala de grises de la imagen en el intervalo continuo de $0$ a $1$. Para graficar dicha imagen en el cuadrante $x-y$ (delimitado al rango $[0,1]$ para ambas dimensiones) se usará la función $image( \period )$. Esta función despliega la figura interpretando al renglón como la coordenada $x$ y a la columna como la coordenada $y$. Sin embargo, esta es una interpretación distinta a la asignación que interpreta a los renglones como el largo (es decir, el eje $y$) y a las columnas como el ancho (es decir, el eje $x$) y que es tal como se conforma el output de $readPNG( \period )[,,1]$. De tal manera, si se computa la escala de grises de este output mediante $image( \period )$ se tendría como resultado la imagen rotada 90º en sentido contrario a las manecillas del reloj (hacia la izquierda), como se muestra en la siguiente imagen. 

\begin{figure} [h]
  \centering
   \includegraphics[width=0.4\linewidth]{orig.png}
  \caption{Despliegue image(.), matriz original }
  \label{partes }
\end{figure}


Para solventar este problema se usará una versión auxiliar de la matriz original, rotándola 90º en sentido de las manecillas del reloj. El resultado se despliega a continuación. 

\begin{figure} [h]
  \centering
   \includegraphics[width=0.4\linewidth]{orig rot.png}
  \caption{Despliegue image(.), matriz rotada 90 a la derecha  }
  \label{partes }
\end{figure}


El siguiente paso consiste en usar las dimensiones $m$ y $n$ para delimitar el tamaño de la matriz tal que se permita generar una partición de la misma en submatrices que sea factible ante los \textit{inputs} enviados a la función de partición. Se requiere que la cantidad de renglones de la nueva matriz acotada sea $0$ módulo $m$ y, la cantidad de columnas, $0$ módulo $n$. Si bien puede haber más de una combinación renglón $\times$ columna consistente con las propiedades mencionadas, se escoge una nueva dimensión $\mu' \times \nu'$ que corresponda al máximo valor factible que no exceda $\mu \times \nu$.  

\begin{equation} \label{dimensiones} 
DIM = \{ (\mu'=max(a), \nu'=max(b) | 0=a mod(m), 0=b mod(n), a \in [0,\mu] \cap \mathbb{N},  b \in [0,\nu] \cap \mathbb{N} \}
\end{equation}

Es trivial notar que se requiere que $m \leq \mu$ y  $n \leq \nu$. El acotamiento arriba expresado se realiza de la manera más simétrica posible. Esto es, si $\mu' < \mu$, se recortarán $\epsilon= \floor{   \frac{1}{2}(\mu - \mu') }$ renglones por arriba y $\delta = (\mu - \mu ')- \epsilon$ renglones por abajo . Así, se tendrá $\epsilon - \delta \in \{0, 1 \}$ ($0$ si $\frac{1}{2}(\mu - \mu')$ es par, $1$ e.o.c), lo cual quiere decir que, en el peor caso, se recortará un pixel más por un lado que por otro. Análogamente, si $\nu' < \nu$, se recortarán $\rho= \floor{   \frac{1}{2}(\nu - \nu') }$ columnas por la izquierda y $\sigma = (\nu - \nu ')- \rho$ por la derecha (siendo también la diferencia de, a lo mucho, uno). El siguiente paso consiste en convertir la matriz de la escala $[0,1]$ a la escala $\{ 0, \dots, 255\}$. Luego, se procede a fraccionar la matriz en un conjunto de $m \; n$ submatrices mediante la función $matsplitter(.)$ de R, la cual recibe como entradas la matriz a fraccionar, la cantidad de renglones por submatriz, $k=\mu ' / m$ y la cantidad de columnas,  $h=\nu ' / n$. $matsplitter( \period )$ entregará una lista de $m \times n$ elementos. Los elementos $1$ a $n$ de la lista consistirán en las primeras $n$ submatrices superiores de la matriz, los elementos $n +1$ a $2n$ consistirán en las segundas $n$ submatrices superiores. Así sucesivamente, hasta llegar a las $n$ submatrices inferiores, ennumeradas $n \; m-n+1$ a $m \; n$. En el supuesto de que cada submatriz representara un único valor numérico (o arreglo $1 \times 1$) dentro de una matriz $m \times n$; entendemos que este tipo de ordenamiento es de clase \textit{rowwise} (o por renglón), ya que se va llenando renglón por renglón, empezando por los renglones de arriba y continuando hacia abajo. Cada renglón se llena de izquierda a derecha. El otro tipo común de ordenamiento es \textit{columnwise}, o por columna\footnotetext{Arreglo por columna, o \textit{columnwise} donde se llenan las columnas de izquierda a derecha, cada columna se llena de arriba a abajo}. Conociendo esto, podemos calcular la luminosidad promedio de cada elemento del output de $matsplitter( \period )$. Dicho conjunto de luminosidades puede sintetizarse en un vector de dimensión $m \; n$. 


\subsection{Arte con el agente viajero}\label{ssec:tspImplem}



Tras haber seguido los pasos de la sub-sección \ref{subsection:partic} lo siguiente consiste en convertir la escala del conjunto $\{0, \dots, 255\}$ a la escala $\{0, \dots , \gamma \}$, empleando la ecuación, ec. \eqref{oscG} desglosada en la sub-sección  \ref{ssec:tspDescrip} de la presente tesina. Así pues, obtenemos un vector de dimensión $m \; n$, llámese $g$. Para el primer ejercicio, asígnese $\gamma=7$. Bajo esta $\gamma$, las escalas primera a treintaiseisava de luminosidad coinciden con la escala $7$ en oscuridad (o siete \say{ciudades}). Las siguientes luminosidades (por orden) corresponden a seis ciudades; sucesivamente, hasta llegar a la escala 255, que corresponde a cero ciudades. Es obvio que situar más puntos, o ubicar más aristas que conecten éstos en un rectángulo generará una mayor oscuridad en el mismo, de ahí que se considere a $g$ como una escala de oscuridad. Lo siguiente consta en ubicar las ciudades en el plano $x-y$, haciendo un loop a través de las $m \; n$ matrices. 


\begin{enumerate}
\item La asignación del k-ésimo elemento de la lista $\{1, \dots , m \; n \}$ a una coordenada de matriz $(i,j)$ se rige por el siguiente pseudocódigo, el cual tiene como base el tipo de arreglo \textit{rowwise}. 


$
mod2=k mod(n) \\
si \; mod2=0 \\
entonces \; i =mod2 \\
e \period o \period c \period \\
         i=mod2\\
j=\frac{(k-i)}{n}+1
$

\item Una vez que tenemos la asignación $k \mapsto (i, j)$, $(i(k), j(k) )$, el siguiente paso es plasmar los puntos que asemejarán a la imagen objetivo sobre el rectángulo $[0,1]\times[0,1]$ en el plano $x-y$. Para ello, vale la pena considerar que el extremo superior izquierdo de la imagen corresponde al elemento $(1,1)$ de la matriz y a la coordenada $(0,1)$ del plano $x-y$. Partiendo de aquí, deducimos la posición del extremo superior izquierdo de la coordenada genérica $(i,j)$ de la matriz. La coordenada $x$ corresponde al pixel con la columna $j$, representando un paso de $\frac{(j-1)}{n}$ a la derecha de $x=0$. La coordenada $y$, con el renglón $i$, corresponde su ubicación en el eje $y$ a un paso de $\frac{(i-1)}{m}$ unidades abajo de $y=1$. Bajo esta formulación, derivamos que cada rectángulo (asociado a una submatriz) tendrá un ancho $\frac{1}{n}$ y un largo de $\frac{1}{m}$. Bajo este planteamiento se puede demostrar que para todo par de coordenadas de matriz de tipo $\{(i, j), (i+1, j)\}$ o  $\{(i, j), (i, j+1)\}$ existirá una relación de adyacencia entre sus correspondientes rectángulos. Además, las esquinas de la figura que envuelve a este conjunto de $m \; n$ rectángulos serán las coordenadas $\{(0,1), (1,1), (0,0), (1,0)\}$. Con esto, garantizamos que los rectángulos mencionados conforman una partición del cuadrado $[0,1] \times [0, 1]$

\item El siguiente paso es usar el valor entero $g_{k}=g[k]$ para colocar esa cantidad de ciudades en el rectángulo asociado a la coordenda $(i(k), j(k) )$. Una alternativa inmediata es colocarlas aleatoriamente, lo cual muy probablemente permitiría reproducir la imagen con buena similaridad. Sin embargo, se propuso hacer una asignación de coordenadas más razonada que obedece a la idea de hacer una buena distribución de las ciudades a lo largo y ancho de su correspondiente rectángulo. Con una \say{buena} distribución se busca dar a entender que se quiere evitar una excesiva concentración de las ciudades en una zona del rectángulo, dejando a otras zonas muy blancas (o sin ciudades). La idea propuesta, pues, es generar un \textit{grid} de coordenadas $\{ x_{0}, x_{1}, \dots , x_{10}  \}$ donde $x_{0}$ y $x_{10}$ corresponden a los extremos izquierdo y derecho del rectángulo y $x_{l+1}-x_{l}=q \forall l \in \{0, \dots ,9 \}$ ($q=\frac{1}{10n}$); otro grid para las coordendas $y$: $\{ y_{0}, y_{1}, \dots, y_{10}  \}$, con $y_{p+1}-y_{p}=r \forall p \in \{0, \dots  ,9 \} $ (  $r=\frac{1}{10m}$ ) con $y_{0}$ y $y_{10}$ extremos superior e inferior.  Con esto, ya habremos construido el \textit{grid} 2-dimensional $G=\{  (x_{i}, y_{i}) | (i,j) \in \{   0, \dots, 10 \}^{2} \}$ que consiste en $121$ coordenadas. Sobre este conjunto de coordenadas aplicar un \textit{k-means} con $g_{k}$ centroides. Una buena asignación de ciudades que cumple la condiciones deseadas (y previamente descritas) es aquella que asocia un centroide a una ciudad. Se procede a guardar esta asignación de ciudades y añadirlas a la selección correspondiente a submatrices anteriores (si es que hay anteriores).

\end{enumerate}

 Al iterar este proceso las $m \; n$ veces, se obtienen las $\sum_{k=1}^{m \; n } g_{k}=\tau$ \footnotetext{esta es una expresión equivalente a la ecuación ec.\eqref{totalCiudades}  , pero en la versión que mapea $(i,j) \rightarrow k(i,j)$ }  ciudades objetivo y podemos resolver el TSP sobre éstas. Los resultados de escribir todos las ciudades como puntos bajo los ejercicios con $15 \times 15$ rectángulos y ($608$ ciudades) y con $50 \times 50$ ($5807$ ciudades) se desglosan a continuación. 
 
 \begin{figure}[h]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twitt15.png}
         \caption{ $15 \times 15$ rectángulos o $608$ ciudades}
         \label{fig:fig15}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twitt50.png}
         \caption{$50 \times 50$ rectángulos o $5807$ ciudades}
         \label{fig:fig50}
     \end{subfigure}
     \hfill
        \caption{Gráfica de los puntos sobre el cuadrante $x-y$}
        \label{fig:dos figuras}
\end{figure}
 
 
 
 Existe un tipo de archivo cuya extensión es \say{.tsp}. Éste se basa en el conjunto de ciudades sobre el que se ha de resolver una instancia del problema lineal. Dicha solución puede procederse mediante distintos métodos o heurísticas y puede realizarse mediante distintos \textit{softwares}, algunos de los cuales son R, Python, Java y Concorde. En aras de practicidad, y en vista de que hasta el momento la construcción de los rectángulos y las ciudades se ha llevado a cabo con R, se usará este lenguaje para manipular tanto objetos como archivos de tipo TSP. Para este efecto se usará la librería homónima cuya función, $ETSP( \period )$ debe su nombre a \textit{Euclidean TSP} y convierte el \textit{data frame} de $2$ columnas (una por coordenada) y $\tau$ renglones (uno por ciudades) en un problema del agente viajero. El \textit{Euclidean} obedece a que las coordenadas podrías ser de otra métrica o terrestres. La función encargada de resolver un etsp es $solveTSP(\period)$. Si bien se le puede ingresar el método a emplear como campo, el que se usa por \textit{default} es el algoritmo de inserción arbitraria con refinamiento de tipo two opt. El tipo de datos del \textit{output} es doble: \textit{tour} y entero. La versión como entero consiste en el orden de las ciudades que se anidan para construir el \textit{tour}. Con ello se puede graficar la solución con ayuda de $ggplot( \period )$. Los resultados con $15 \times 15$ y $50 \times 50$ son los siguientes. 
 
 
  \begin{figure}[h]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittRes15.png}
         \caption{ $15 \times 15$ rectángulos o $608$ ciudades; solución vía TSP}
         \label{fig:fig15r}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittRes50.png}
         \caption{$50 \times 50$ rectángulos o $5807$ ciudades; solución vía TSP}
         \label{fig:fig50r}
     \end{subfigure}
     \hfill
        \caption{Gráfica de las líneas uniendo a los puntos de manera eficiente sobre el cuadrante $x-y$}
        \label{fig:dos figuras}
\end{figure}


\subsection{Fotomosaicos}

Posteriormente a reproducir los pasos descritos en la subsección \ref{ssec:partic}, se procede a convertir la escala del conjunto $\{0, \dots , 255 \}$ a $[0,1]$ dividiendo entre $255$ (ver primer párrafo de la subsección referida). Llámese $h$ al vector resultante de extraer estas escalas promedio de las submatrices ordenadas con base en el esquema \textit{rowwise}. Supóngase que las dimensiones de las imágenes que compondrán el fotomosaico son cuadradas, de valor $pi \times pi$. Entonces, generaremos tres arreglos importantes: uno de parámetros de costos, dos de escalas de grises. El primero será uno numérico  $3$-dimensional de tipo $cf \times m \times n$, llámese $Arr3$, con $Arr3[f,i,j]=c_{fij}$, donde el lado derecho es el mismo ponderador de costos de la expresión \eqref{unoM} . Uno de los arreglos con \textit{greyscales} será de dimensión $m \times n$, tendrá por nombre $mp$, por \say{matriz perfecta} el cual es un eufemismo por tratarse de la mejor representación factible de una imagen con las dimensiones que se le entregan; el otro, será un arreglo de $(m \; pi) \times (n \; pi)$ y será $MF$, por \say{matriz final}. Además, se contará con una dotación de $\sum_{f=1}^{cf } u_{f}$ imágenes de solo $cf$ tipos, cada uno denotado mediante $Mg_{f}$ por las iniciales de  \say{matriz de \textit{grayscales}} de la imagen tipo $f$. A continuación se describe el bucle a través de $m \; n$ iteraciones que es la base para llenar los arreglos mencionados. 




\begin{enumerate}
\item Tomamos el número de iteración, $k$, y le asignamos su correspondiente coordenada matricial, $(i(k), j(k))$ deducida por el esquema \textit{rowwise} (previamente descrito, ver pseudo-algoritmo del primer paso del \textit{loop} en la sección \ref{ssec:tspImplem})

\item Obtener la escala $[0,1]$ de luminosidad del elemento $(i, j)$, $h_{k}$; es decir, el valor promedio de la correspondiente submatriz. 

\item Obtener la diferencia cuadrática de las luminosidades; es decir, la que hay entre $h_{k}$ y cada elemento del vector de luminosidades promedio de las $|F|$ figuras disponibles, llámese $lumP$. Esto es hacer $c_{ij}=[ (h_{k}-lumP_{f} )^{2} ]_{f \in F  } \in [0,1]^{cf }$. Asignar el valor de este vector a los elementos $Arr3[i,j,]$ del arreglo $Arr3$.

\item Asignar el valor $h_{k}$ al elemento $mp[i, j]$ de la matriz perfecta. 

\end{enumerate}

Posteriormente, hay que construir un vector que cuantifique las dotaciones disponibles de las $cf$  figuras. Para ello, nos valemos de dos parámetros: uno, $hd$, de 'holgura', que nos dirá qué tantas más de las fichas estrictamente necesarias tendremos. Si $hd=0.1$, tendremos aproximadamente $10\%$ más de las fichas exactamente suficientes.

Si deséaramos que las disponibilidades de cada ficha fueran uniformes, tendríamos $\ceil{\frac{ m\;n(1-hd)}{cf }}$ imágenes de cada tipo. Sin embargo, para darle mayor variabilidad a estas disponibilidades introducimos $vd$, un parámetro de variabilidad que nos permitirá tener una dotación de la ficha $f$ extraída aleatoriamente de entre todos los enteros en $ u_{f} \in \{  \ceil{\frac{ m\;n(1-hd)}{cf} (1-vd) } , \dots ,   \ceil{\frac{ m\;n(1-hd)}{cf} (1+vd) } \}$. A mayor $vd \in [0,1]$, mayor será la varianza del vector $u$ de disponibilidades. 

Con los pasos 1 a 4 del \textit{loop} y la construcción de $u$ que le es posteriormente descrita se habrán generado los parámetros necesarios para definir el modelo. El siguiente paso radica en reestructurar la información plasmada en el arreglo $Arr3$ en un \textit{data frame}, $df3$ que consiste en los campos: $t, i, j, f, ce$ y cuya forma genérica se muestra a continuación. 

\begingroup
%\setlength{\tabcolsep}{0.75pt} % Default value: 6pt
\renewcommand{\arraystretch}{0.6} % Default value: 1

\begin{center}
%\setlength\tabcolsep{1.5pt}
%\renewcommand{\arraystretch}{1.2}

\begin{tabular}{c*{6}{c}r}
%\renewcommand{\arraystretch}{1}
t & f & i & j & costo ($ce$)  \\
\hline
1 & 1 & 1 & 1 & A[1,1,1]   \\
2 & 1 & 1 & 2 & A[1,1,2]   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
n & 1 & 1 & n & A[1,1,n]   \\
n+1 & 1 & 2 & 1 & A[1,2,1]   \\
n+2 & 1 & 2 & 2 & A[1,2,2]\\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
2n & 1 & 2 & n & A[1,2,n]   \\
%. & . & . & . & .   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
(m-1)n+1 & 1 & m & 1 & A[1,m,1]   \\
(m-1)n+2  & 1 & m & 2 & A[1,m,2]\\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
mn & 1 & m & n & A[1,m,n]   \\


mn+1 & 2 & 1 & 1 & A[2,1,1]   \\
mn+2 & 2 & 1 & 2 & A[2,1,2]   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
mn+n & 2 & 1 & n & A[2,1,n]   \\
mn+n+1 & 2 & 2 & 1 & A[2,2,1]   \\
mn+n+2 & 2 & 2 & 2 & A[2,2,2]   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
mn+2n & 2 & 2 & n & A[2,2,n]\\
%. & . & . & . & .   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
mn+(m-1)n+1 & 2 & m & 1 & A[2,m,1]   \\
mn+(m-1)n+2  & 2 & m & 2 & A[2,m,2]   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\
2mn & 2 & m & n & A[2,m,n]   \\

%. & . & . & . & .   \\
%. & . & . & . & .   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\


(cf-1)mn+1 & cf & 1 & 1 & A[cf,1,1]   \\
(cf-1)mn+2 & cf & 1 & 2 & A[cf,1,2]  \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\

(cf-1)mn+n & cf & 1 & n & A[cf,1,n]   \\
(cf-1)mn+n+1 & cf & 2 & 1 & A[cf,2,1]   \\
(cf-1)mn+n+2 & cf & 2 & 2 & A[cf,2,2]   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\

(cf-1)mn+2n & cf & 2 & n & A[cf,2,n]   \\
%. & . & . & . & .   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\

(cf-1)mn+(m-1)n+1 & cf & m & 1 & A[cf,m,1]   \\
(cf-1)mn+(m-1)n+2  & cf & m & 2 & A[cf,m,2]   \\
%. & . & . & . & .   \\
\vdots  & \vdots  & \vdots  & \vdots  & \vdots    \\

m\;n\;cf & cf & m & n &  A[cf,m,n]
\end{tabular}
\end{center}
\endgroup



Como se muestra, el ordenamiento de $df3$ sigue la jerarquía $f,i,j$. Con ayuda de esta tabla, podemos definir el modelo en un objeto de clase \say{lp}, auxiliándonos en el módulo $lpSolve$ de $R$. Dicho objeto se basa en (a) un vector de pesos, $ce$, (b) una instrucción de optimización, $io$: \say {minimiza} o \say{maximiza}, (c) una matriz $RM$ de restricciones con dimensiones $re \times (m \;n \;f)$ que representa a las $re$ restricciones existentes sobre las variables (d) un vector de lados derechos, $rh \in \mathbb{R}^{re}$ con el valor contra el cual será contrastada la combinación lineal de $x$, $RM[row,] \cdot x$, (e) un vector de carácteres, $sign$, con el cual la restricción t-ésima será   $RM[row,] \cdot  x \; \say{sign[t]} \; rh_{t}$, con $sign \in \{\say{<} ,\say{\leq}, \say{>},\say{\geq}  \}$.

La estructura descrita redefine el problema, para este caso, pasando de uno sobre variables de decisión indexadas sobre tres componentes $x_{fij}$ a su análogo 1-dimensional, $x_{t}$. El ejercicio requiere de una reasignación $(f, i, j) \mapsto t(f, i, j)$ definida por $t=(f-1) \;(m \;n) + m(i-1)+j$ que representa el orden de los renglones que sigue $df3$. Ahora, defínanse en $R$ los parámetros requeridos en el párrafo anterior



\begin{enumerate}[label=(\alph*)]
\item $ce=df3[\say{costo}]$
\item $io=\say{min}$
\item Restricciones $RM \in \mathbb{R}^{re \times m \; n \; cf}$ con $re=cf+m\;n$, los primeros $cf$ renglones representando a las restricciones de disponibilidad de las fichas que hay, y las restricciones restantes representando el correcto llenado de cada celda genérica $(i, j)$. La matriz consta únicamente de valores $0$ y $1$. Los $1$'s se asignan facilmente conociendo, con la ayuda de la asginación $t( \period )$ qué posiciones corresponden a cada $f$ para el primer conjunto de restricciones; similarmente, para el segundo conjunto de restricciones basta reconocer qué posiciones le corresponden a cada celda $(i,j)$. 

\item $rh_{f}=u_{f} \; \forall f \in \{1, \dots , cf\}$

$rh_{t}=1 \;  \forall f \in \{cf+1, \dots , cf+m\;n\}$

\item $sign_{f}=\say{\leq} \; \forall f \in \{1, \dots , cf\}$

$sign_{t}=\say{=} \;  \forall f \in \{cf+1, \dots , cf+m\;n\}$
\end{enumerate}


Si bien el problema no fue restringido a enterez, el resultado es entero y consta únicamente de $0$'s y $1$'s. Si extraemos únicamente los valores $T=\{t | x_{t}=1  \}$ en una tabla $dfSel$ con campos $t, f, i, j$ y obtenemos la imagen de función inversa de $t(  \period )$ sobre $T$, se valida que las $m\;n$ combinaciones $(i,j)$ son cubiertas exactamente una única vez cada una y que cada figura en $F$ se ocupa en una cantidad de ocasiones que no excede su correspondiente límite definido en $u$. Habiendo supuesto que la dimensión de las $cf$ figuras es de $pi \times pi$ y sea $MG_{f} \in \mathbb{R}^{pi \times pi}$ la matriz de \textit{greyscales} de la figura $f$, entonces procedemos a llenar el fotomosaico mediante el siguiente \textit{loop}: a través de $m\;n$ iteraciones hacer lo siguiente. 

\begin{enumerate}
\item Extraemos el $\kappa$-ésimo vector-renglón.$S_{\kappa}=dfSel[\kappa, ]$. Así, obtenemos $S_{\kappa}[\say{t}]=t$, $S_{\kappa}[\say{i}]=i(t)$, $S_{\kappa}[\say{j}]=j(t)$, $S_{\kappa}[\say{f}]=f(t)$, con el renglón, la columna y la figura inferidas de la función inversa de $t(.)$

\item Definimos el extremo superior izquierdo de la imagen $f(t)$ sobre la matriz final, $MF[rI, cI]$. Sígase que $rI(t)=(  i(t)-1 )pi+1$ y  $cI(t)=(  j(t)-1 )pi+1$

\item Luego, se asigna el valor de $MF_{f(t)}$ a la submatriz con el extremo superior izquierdo en $(rI, cI)$; esto es, $MF[\{rI, \dots ,  rI+pi-1 \}, \{cI, \dots ,  cI+pi-1 \}]=MG_{f}$

\end{enumerate}

Se puede validar que este procedimiento llena por completo y con valores factibles a la matriz $MF$. 

El siguiente paso es ejecutar los pasos descritos hasta este punto de la subsección usando una gama de imágenes cuadradas y buscando emular el logo de Twitter. Para ello, se generó un código de R que lee todos los archivos png de una subcarpeta y extrae sus dimensiones (pixeles). Posteriormente elige la mínima dimensión (de entre columnas y renglones) del conjunto de imágenes, acota a todas las imágenes de manera que cumplan con esta dimensión a lo largo y ancho y guarda su luminosidad promedio. Además, define un intervalo, $i=1/ cf$, con $cf \in  \mathbb{N}$ sobre el cual se seleccionará la imagen. Esto es, si $i=0 \period 05$ entonces las figuras se clasificarán en $cf=20$ categorías, a saber, $\{[0,0 \period 05), [0 \period 05,0 \period 10) , [0 \period 10,0 \period 15),  \period  \period  \period  , [0 \period 90,0 \period 95), [0  \period  95,1] \}$. Para el primer ejercicio extraemos las imágenes de un conjunto de $60$ fotos de una cuenta de Instagram. Al computar su luminosidad se encuentra que las $20$ categorías no son todas cubiertas, estando las imágenes acotadas en luminosidades entre $0 \period 30$ y $0 \period  75$. Para hacer que la cantidad de categorías cubiertas sea de $20$ entonces se oscurecen o iluminan más tantas imágenes como categorías falten por cubrir. El resultado de hacer la selección de $20$ imágenes, ordenadas por luminosidad de menor a mayor, se muestra a continuación. 


\begin{figure} [h]
  \centering
   \includegraphics[width=0.7\linewidth]{catalogoFin.png}
  \caption{Catálogo de imágenes seleccionadas para el fotomosaico  }
  \label{catal}
\end{figure}



Habiendo seleccionado las imagenes se procede a reproducir el ejercicio de los fotomosaicos. Al hacerlo con $dp=0 \period 3$ y $vp=0 \period 3$, podemos desplegar la imagen resultante con dimensiones $15 \times 15$ y $20 \times 20$

 
  \begin{figure}[h]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittMos15.png}
         \caption{Fotomosaico: $20$ tipos de figuras,  $15 \times 15$ mosaicos}
         \label{fig:fig15m}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittMos20.png}
         \caption{Fotomosaico: $20$ tipos de figuras,  $20 \times 20$ mosaicos}
         \label{fig:fig20m}
     \end{subfigure}
     \hfill
        \caption{Soluciones gráficas al problema de los fotomosaicos con $dp=0 \period 3$ y $vp=0 \period 3$; 
        dimensiones $15 \times 15$ y $20 \times 20$
        }
        \label{fig:dos figurasIn}
\end{figure}

Claramente el resultado ha mostrado ser, visualmente, eficiente. La matriz $mp$ sirve como referencia para ver cómo se vería la imagen si se deseara desplegar la mejor representación posible de la imagen original contando exactamente con dimensiones de pixel $m \times n$. El resultado se muestra a continuación. 



 \begin{figure}[h]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{mp15.png}
         \caption{Matriz perfecta, dimensiones  $15 \times 15$}
         \label{fig:mper15}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
     \centering
         \includegraphics[width=\textwidth]{mp20.png}
         \caption{Matriz perfecta, dimensiones  $20 \times 20$}
         \label{fig:mper20}
     \end{subfigure}
     \hfill
        \caption{Matrices perfectas basadas en luminosidades promedio de submatrices 
        }
        \label{fig:dos figurasPerf}
        %\label{fig:jobInformationDialog}
\end{figure}

Una cuestión interesante de abordar es el atributo de escasez de fichas en el problema, el cual se concentra en el vector de parámetros, $u$. Inspeccionando visualmente la imagen original, o bien, incluso a la versión de $mp$ de la misma, se puede observar que todos los contornos de la imagen (alrededor del pajaro) tienen la máxima luminosidad disponible. Esto incluye, naturalmente a los extremos inferior derecho y superior derecho. Sin embargo, al ver el fotomosaico en figura \ref{fig:dos figurasIn} se observa claramente que las celdas inferiores derecha tienen una luminosidad muy elevada (cercana a $1$), en tanto que la luminosidad de la superior derecha es alta, pero claramente menor. Esto ocurre porque, si bien pudiera ser deseable que todos los contornos tuvieran el máximo de luminosidad, existe una disponibilidad limitada de la ficha más blanca, así como de todas en general. Por lo tanto, se recurren a otras fichas, lo menos oscuras posibles que minimicen la suma de diferencias cuadráticas de luminosidades para cubrir el contorno del ave sin exceder los recursos existentes. Haciendo uso de los parámetros introducidos y explicados en el presente escrito, podríamos hacer el ejericio sin limitar estos recursos. Basta indicar que $hd=m \; n$, queriendo decir que, si tuviéramos dimensiones $m\times n= 15\times 15$, entonces las fichas disponibles son $15^{2}=225$ y, si asignamos $hd=225$, entonces dispondremos de $22500\%$ más de las fichas estrictamente necesarias. Además, si $vd=0$ las disponibilidades se distribuirán homogéneamente, con lo cual garantizamos que cada tipo de ficha tiene el potencial de llenar todo el fotomosaico con fichas de un solo tipo. Así pues, a continuación se muestra el resultado de hacer $hd=m\;n$ y $vd=0$


  \begin{figure}[h]
     \centering
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittMosPerf15.png}
         \caption{Fotomosaico: $20$ tipos de figuras,  $15 \times 15$ mosaicos}
         \label{fig:figp15m}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.4\textwidth}
         \centering
         \includegraphics[width=\textwidth]{twittMosPerf20.png}
         \caption{Fotomosaico: $20$ tipos de figuras,  $20 \times 20$ mosaicos}
         \label{fig:figp20m}
     \end{subfigure}
     \hfill
        \caption{Soluciones gráficas al problema de los fotomosaicos con $dp=m\;n$ y $vp=0$; 
        dimensiones $15 \times 15$ y $20 \times 20$
        }
        \label{fig:dos figuras}
\end{figure}

Claramente, estas imágenes tienen contornos más blancos y los fotomosaicos asemejan más a los resultados de usar los valores de matriz perfecta para \textit{greyscales}, \ref{fig:dos figurasPerf}. Lamentablemente, se observa claramente que no todos los $20$ tipos de fichas disponibles se están empleando. 

\section{Referencias}
[1]

\end{doublespace}
\end{document}
